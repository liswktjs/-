# 동적계획법 (DP, BP) 관련 정리 

#### 삼각형 문제 

최상위층 부터 시작하여서 층을 하나씩 내려오면서 더한 값이 가장 큰 수가 되도록 하는 문제 

-> 어떤 값을 어떻게 선택하냐에 따라서 답이 달라지기 떄문에 완전탐색법을 사용할 수 도 있으나 그렇게 된다면
시간이 오래 소요되기 때문에 사용하지 않고, 위층에서부터 값을 더 해서 오기 때문에 동적계획법을 적용하여
문제를 푸는 것이 더 효과적이다 

2차원 배열 생성 (0까지 포함해서 배열을 만들어서 인덱스가 리스트 범위 밖으로 넘어가는 것을 막는다) 
DP 배열도 같은 방식으로 생성한다 
```
arr = [[0 for _ in range(n+1)] for i in range(n+1)]
```
- bottom up으로 하는 방법
:dp[i][j] : i, j 번째를 도착 했을 때의 최대값이 되야 하므로 max(dp[i=1][j-1], dp[i-1][j])로 업데이트 

```
for i in range(1,n+1):
  for j in range(1, i+1):
    dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + arr[i][j]
    
print(max(dp[-1])) //answer
```
-> 이전 층의 왼쪽 오른쪽의 숫자중 큰 것을 선택하여 현재 값과 더 해준다 
맨 첫줄부터는 0으로 채워지나 arr[i][j]를 더하기 때문에 원래의 배열 값이 dp 배열에 추가 되면서 큰 값을 찾아간다 

#### 가장 큰 증가 부분 수열 

수열 a 가 주어졌을 때, 그 수열의 증가 부분 수열 중에서 합이 가장 큰 것을 구하는 문제

a = [1, 100, 2, 50, 60, 3, 5, 6, 7, 8] 이 주어졌을 때 가장 큰 증가 수열 부분은 1, 2, 50, 60이고 이들의 합은 113이다 

-> 이전 원소보다 현재 원소 값이 증가했을 경우 들에서 모두 조건을 만족하므로 만들 수 있는 부분 집합의 개수가 커지게 된다 / 그래서 dp를 통한 풀이법이 필요하다


dp[i]: i 까지 왔을 때 값의 최대 값 

dp 선언은 입력받은 수열 a의 값을 그대로 해준다 / 시간 복잡도 n^2
```
for i in range(1, len(a):
  for j in range(i):
    if a[i] > a[j]:
      dp[i] = max(a[i] + dp[j], dp[i])
      
print(max(dp))
```
-> 증가하는 수열이여야 하기 때문에 j를 i 전까지 증가하도록 제한 한다 추가로 i의 경우 배열 내의 원소를 모두 돌기 떄문에 모든 증가하는 수열에 대한 경우에 대해 처리 할 수 있다

###### Q+ 증가하는 수열 부분(경로, 리스트를) 출력하고자 할 때

배열을 추가적으로 하나 더 생성해준다 

```
rev = [i for i in range(n)] 
idx = 0
for i in range(1, len(a):
  for j in range(i):
    if a[i] > a[j] and dp[i] < a[i] + dp[j] :
      dp[i] = a[i] + dp[j]
      rev[i] = j 
   
   if dp[idx] < dp[i]:
    idx = i  ### idx 는 가장 dp 원소들 중 가장 큰 값을 가지고 있는 원소의 인덱스 값을 가지게된다 
    
while rev[idx] != idx:
  print(a[idx])
  idx = rev[idx]
  
print(rev[idx])
```
-> rev는 자신에게 더해진 원소들의 인덱스를 가리키게 된다 해당 인덱스들을 반대로 쫓아가면서 출력한다 


#### 2차원 배열의 합 

2차원 배열이 주어졌을 때 (i,j)의 위치부터 (x,y)위치까지 저장되어 있는 수들의 합을 구하는 코드 작성 

-> 교집합을 뺴야한다라는 아이디어를 활용한다 

